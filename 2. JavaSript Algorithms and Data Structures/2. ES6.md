<style>
@media only screen {
	p strong, p em {color:#d79921;}
}
</style>

{{TOC}}

+++
## ES6
ECMAScript, or ES, is a standardized version of JavaScript. Because all major browsers follow this specification, the terms ECMAScript and JavaScript are interchangeable.

Most of the JavaScript you've learned up to this point was in ES5 (ECMAScript 5), which was finalized in 2009. While you can still write programs in ES5, JavaScript is constantly evolving, and new features are released every year.

ES6, released in 2015, added many powerful new features to the language.

### Compare Scopes of the `var` and `let` Keywords
Variable declaration with
- `var` → globally or locally if it's inside a function
- `let` → scope limited to the block where it's being declared

Examples:

```js
var numArray = [];
for (var i=0; i<3; i++) {
	numArray.push(i);
}
console.log(numArray); //[0, 1, 2]
console.log(i) //3
```

With the `var` keyword `i` is declared globally, and the execution of `i++` updates it. Its similar to the following:

```js
var numArray = [];
var i;
for (i=0; i<3; i++) {
	numArray.push(i);
}
console.log(numArray); //[0, 1, 2]
console.log(i) //3
```

This behavior will cause problems if you were to create a function and store it for later use inside a `for` loop that uses the `i` variable. This is because the stored function will always refer to the value of the updated global `i` variable.

```js
var printNumTwo;
for (var i = 0; i < 3; i++) {
  if (i === 2) {
    printNumTwo = function() {
      return i;
    };
  }
}
console.log(printNumTwo()); //3
```

It prints `3` and not `2` because the value assigned to `i` was updated, and the `printNumTwo()` returns the global `i` and not the value `i` had when the function was created in the for loop.  
The `let` keyword does not follow this behavior:

```js
let printNumTwo;
for (let i = 0; i < 3; i++) {
  if (i === 2) {
    printNumTwo = function() {
      return i;
    };
  }
}
console.log(printNumTwo()); //2
console.log(i); //i is not defined
```

The error `i is not defined` is because `i` was not declared in the global scope, only within the `for` loop statement. `printNumTwo()` returned the correct value because three different `i` variables with unique values (0, 1 and 2) where created.

### Mutate an Array Declared with `const`
Some developers prefer to assign their variables using `const` by default, unless they know they will need to reassign the value, where they use `let`.

Objects (including arrays and functions) assigned with `const` are still mutable, it only prevents reassignment of the variable identifier.

```js
const s = [5, 7, 2];
function editInPlace() {
  // Using s = [2, 5, 7] would be invalid
  s[0]=2; s[1]=5; s[2]=7;
}
editInPlace();
```

### Prevent Object Mutation
Using `const` doesn't protect your data from mutation, to ensure your data doesn't change there's a function `Object.freeze(myObj)`

### Use Arrow Functions to Write Concise Anonymous Functions
Inline functions are those ones that don't need name because we don't reuse them anywhere else.  
Syntax:

```js
const myFunc = function() {
	const myVar = "value";
	return myVar;
}
```

ES6 provides us with the syntactic sugar to not have to write anonymous functions this way. Instead, you can use **arrow function syntax**:

```js
const myFunc = () => {
	const myVar = "value";
	return myVar;
}
```

When there is no function body, and only a return value, arrow function syntax allows you to omit the keyword `return` as well as the brackets surrounding the code. Smaller funtions get simplified:

```js
const myFunc = () => "value";
```

### Write Arrow Functions with Parameters
You can pass arguments into an arrow function, and if it has a single argument the parentheses can be omitted:

```js
const doubler = item => item * 2;

const multiplier = (item, multi) => item * multi;
```

### Set Default Parameters for Your Functions
ES6 introduces *default parameters* for functions.

```js
const greeting = (name="Anonymous") => "Hello " + name;
console.log(greeting("John"));  // Hello John
console.log(greeting());        // Hello Anonymous
```

### Use the Rest Parameter with Function Parameters
In order to help us create more flexible functions, ES6 introduces the *rest parameter* for function parameters. With the rest parameter, you can create functions that take a variable number of arguments. These arguments are stored in an array that can be accessed later from inside the function.

```js
function howMany(...args) {
  return "You have passed " + args.length + " arguments.";
}
console.log(howMany(0, 1, 2));  // You have passed 3 arguments.
console.log(howMany("string", null, [1, 2, 3], { }));  // You have passed 4 arguments.
```

The rest parameter eliminates the need to check the `args` array and allows us to apply `map()`, `filter()` and `reduce()` on the parameters array.

```js
/* const sum = (x, y, z) => {
  const args = [x, y, z];
  return args.reduce((a, b) => a + b, 0);
} */

const sum = (...args) => {
  return args.reduce((a,b) => a+b, 0);
};

console.log(sum(1,2,3));
```

### Use the Spread Operator to Evaluate Arrays In-Place

ES6 introduces the *spread operator*, which allows us to expand arrays and other expressions in places where multiple parameters or elements are expected.

The ES5 code below uses `apply()` to compute the maximum value in an array:

```js
var arr = [6, 89, 3, 45];
var maximus = Math.max.apply(null, arr);  //89
```

We had to use `Math.max.apply(null, arr)` because `Math.max(arr)` returns `NaN`. `Math.max()` expects comma-separated arguments, but not an array. The spread operator makes this syntax much better to read and maintain.

```js
const arr = [6, 89, 3, 45];
const maximus = Math.max(...arr); //89
```

`...arr` returns an unpacked array. In other words, it *spreads* the array. However, the spread operator only works in-place, like in an argument to a function or in an array literal. The following code will not work:

```js
const spreaded = ...arr;
```

Copy all contents of `arr1` into another array `arr2` using the spread operator.

```js
const arr1 = ['JAN', 'FEB', 'MAR', 'APR', 'MAY'];
let arr2 = [...arr1];
console.log(arr2);
```

### Use Destructuring Assignment to Extract Values from Objects

### Use Destructuring Assignment to Assign Variables from Objects

### Use Destructuring Assignment to Assign Variables from Nested Objects

### Use Destructuring Assignment to Assign Variables from Arrays

### Destructuring via rest elements

### Use Destructuring Assignment to Pass an Object as a Function's Parameters

### Create Strings using Template Literals

### Write Concise Object Literal Declarations Using Object Property Shorthand

### Write Concise Declarative Functions with ES6

### Use class Syntax to Define a Constructor Function

### Use getters and setters to Control Access to an Object

### Create a Module Script

### Use export to Share a Code Block

### Reuse JavaScript Code Using import

### Use `*` to Import Everything from a File

### Create an Export Fallback with export default

### Import a Default Export

### Create a JavaScript Promise

### Complete a Promise with resolve and reject

### Handle a Fulfilled Promise with then

### Handle a Rejected Promise with catch
